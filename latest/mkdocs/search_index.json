{
    "docs": [
        {
            "location": "/", 
            "text": "TimeAxisArrays.jl\n\n\nA convenience wrapper around AxisArrays.jl for working with time series data\n\n\nTimeAxisArrays.jl augments \nAxisArrays.jl\n with functionality for time series analysis. A \nTimeAxisArray\n is simply an \nAxisArray\n with the first axis constrained to be dimensional and labelled \n:Timestamp\n, and all remaining axes categorical. It inherits all \nAxisArray\n functionality such as indexing, merging and joining, and math and logic operations, while gaining additional functionality for common time series operations such as temporal downsampling, differencing, lead, and lag.\n\n\nThis package is currently a work-in-progress and so is unregistered - to install, first install \nAxisArrays.jl\n (which is also unregistered) and run:\n\n\njulia\n Pkg.clone(\nhttps://github.com/GordStephen/TimeAxisArrays.jl\n)\n\n\n\n\n\n\nUser Guide\n\n\n\n\nGetting Started\n\n\nCreating \nTimeAxisArray\ns\n\n\nIndexing\n\n\n\n\n\n\nCombing multiple TimeAxisArrays\n\n\nCombining on existing axes\n\n\nCombining into a new axis\n\n\n\n\n\n\nSplitting, collapsing, and downsampling on timestamps\n\n\nSplitting\n\n\nCollapsing\n\n\nDownsampling\n\n\n\n\n\n\nOther time series utilities\n\n\nRolling reductions\n\n\nLead and lag\n\n\nAbsolute and percent differencing\n\n\n\n\n\n\nFile IO\n\n\nReading from disk\n\n\nWriting to disk", 
            "title": "Home"
        }, 
        {
            "location": "/#timeaxisarraysjl", 
            "text": "A convenience wrapper around AxisArrays.jl for working with time series data  TimeAxisArrays.jl augments  AxisArrays.jl  with functionality for time series analysis. A  TimeAxisArray  is simply an  AxisArray  with the first axis constrained to be dimensional and labelled  :Timestamp , and all remaining axes categorical. It inherits all  AxisArray  functionality such as indexing, merging and joining, and math and logic operations, while gaining additional functionality for common time series operations such as temporal downsampling, differencing, lead, and lag.  This package is currently a work-in-progress and so is unregistered - to install, first install  AxisArrays.jl  (which is also unregistered) and run:  julia  Pkg.clone( https://github.com/GordStephen/TimeAxisArrays.jl )", 
            "title": "TimeAxisArrays.jl"
        }, 
        {
            "location": "/#user-guide", 
            "text": "Getting Started  Creating  TimeAxisArray s  Indexing    Combing multiple TimeAxisArrays  Combining on existing axes  Combining into a new axis    Splitting, collapsing, and downsampling on timestamps  Splitting  Collapsing  Downsampling    Other time series utilities  Rolling reductions  Lead and lag  Absolute and percent differencing    File IO  Reading from disk  Writing to disk", 
            "title": "User Guide"
        }, 
        {
            "location": "/man/getting-started/", 
            "text": "Getting Started\n\n\n\n\nCreating \nTimeAxisArray\ns\n\n\nA simple one-dimensional\nTimeAxisArray\n can be created with as:\n\n\nusing TimeAxisArrays\n\ntstamps = 1:10\ndata = randn(10)\nTimeAxisArray(data, timestamps)\n\n\n\n\nTimestamps can be any sortable type. For example, \nDate\ns or \nDateTime\ns are often useful as timestamps:\n\n\ntstamps = Date(2000,1,1):Date(2000,1,10)\nTimeAxisArray(data, timestamps)\n\n\n\n\nIn additional to a temporal dimension, \nTimeAxisArray\ns can store data across an arbitrary number of categorical dimensions as well. For example:\n\n\ndata = randn(10, 3, 2)\nTimeAxisArray(data, timestamps, [:Red, :Green, :Blue], [:Apple, :Banana])\n\n\n\n\nThe first dimension (axis) is always called \nTimestamp\n. Subsequent axes are automatically assigned names, but can be given custom names as well:\n\n\na = TimeAxisArray(data, timestamps, Axis{:Color}([:Red, :Green, :Blue]), Axis{:Fruit}([:Apple, :Banana]))\n\n\n\n\n\n\n\nIndexing\n\n\nIndexing is identical to \nAxisArray\ns. As with standard \nArray\ns, individual elements or ranges can be accessed by providing the relevant value along each axis:\n\n\na[Date(2000,1,3), :Green, :Banana]\na[Date(2000,1,3), [:Red, :Blue], :Banana]\na[Date(2000,1,3), :, :Banana]\n\n\n\n\nIn some cases it's preferable to only reference data according to a specific axis. In those cases the \nAxis\n constructor can be used:\n\n\na[Axis{:Fruit}(:Banana)]\n\n\n\n\nFinally, all timestamps in a given interval can be selected with \n..\n:\n\n\na[Date(2000,1,3) .. Date(2000,1,7), :, :]\na[Date(2000,1,3) .. Date(2000,1,7), [:Red, :Blue], :Banana]", 
            "title": "Getting Started"
        }, 
        {
            "location": "/man/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/man/getting-started/#creating-timeaxisarrays", 
            "text": "A simple one-dimensional TimeAxisArray  can be created with as:  using TimeAxisArrays\n\ntstamps = 1:10\ndata = randn(10)\nTimeAxisArray(data, timestamps)  Timestamps can be any sortable type. For example,  Date s or  DateTime s are often useful as timestamps:  tstamps = Date(2000,1,1):Date(2000,1,10)\nTimeAxisArray(data, timestamps)  In additional to a temporal dimension,  TimeAxisArray s can store data across an arbitrary number of categorical dimensions as well. For example:  data = randn(10, 3, 2)\nTimeAxisArray(data, timestamps, [:Red, :Green, :Blue], [:Apple, :Banana])  The first dimension (axis) is always called  Timestamp . Subsequent axes are automatically assigned names, but can be given custom names as well:  a = TimeAxisArray(data, timestamps, Axis{:Color}([:Red, :Green, :Blue]), Axis{:Fruit}([:Apple, :Banana]))", 
            "title": "Creating TimeAxisArrays"
        }, 
        {
            "location": "/man/getting-started/#indexing", 
            "text": "Indexing is identical to  AxisArray s. As with standard  Array s, individual elements or ranges can be accessed by providing the relevant value along each axis:  a[Date(2000,1,3), :Green, :Banana]\na[Date(2000,1,3), [:Red, :Blue], :Banana]\na[Date(2000,1,3), :, :Banana]  In some cases it's preferable to only reference data according to a specific axis. In those cases the  Axis  constructor can be used:  a[Axis{:Fruit}(:Banana)]  Finally, all timestamps in a given interval can be selected with  .. :  a[Date(2000,1,3) .. Date(2000,1,7), :, :]\na[Date(2000,1,3) .. Date(2000,1,7), [:Red, :Blue], :Banana]", 
            "title": "Indexing"
        }, 
        {
            "location": "/man/combining/", 
            "text": "Combing multiple TimeAxisArrays\n\n\nTimeAxisArray\n combination methods are identical to those in \nAxisArray\n, but are documented here for convenience.\n\n\n\n\nCombining on existing axes\n\n\nMultiple \nTimeAxisArray\ns can be joined together along an existing axis with \nmerge\n - this can be thought of as an axis-aware form of concatenation:\n\n\na = TimeAxisArray(ones(5), 7:11)\nb = TimeAxisArray(zeros(5), 1:5)\nmerge(a,b)\n\n\n\n\nmerge\n works along any number of axes. If an axis coordinate appears more than once in the \nTimeAxisArray\ns to be merged, the value in the last provided input is kept.\n\n\na = TimeAxisArray(ones(5,2), 1:5, [:A, :B])\nb = TimeAxisArray(zeros(5,2), 3:7, [:B, :C])\nmerge(a,b)\n\n\n\n\nAs shown above, in some cases new array elements that were not defined in any of the inputs to the merge will be created. By default these values are zero, but they can be set to any arbitrary value with the \nfillvalue\n keyword:\n\n\nmerge(a,b, fillvalue=NaN)\n\n\n\n\n\n\nCombining into a new axis\n\n\nTimeAxisArrays\n can also be combined so as to preserve elements at repeated axis coordinates by combining the inputs along a newly created axis with the \njoin\n method:\n\n\njoin(a,b)\n\n\n\n\nThe name and values of the new axis can be specified using the \nnewaxis\n keyword, and \nfillvalue\n can be provided as with \nmerge\n:\n\n\njoin(a,b, newaxis=Axis{:Order}([:First, :Second]), fillvalue=NaN)\n\n\n\n\nInner, left, right, and outer join methods are supported, with outer used by default:\n\n\njoin(a, b, method=:outer) # same as join(a,b)\njoin(a, b, method=:left)\njoin(a, b, method=:right)\njoin(a, b, method=:inner)", 
            "title": "Combining TimeAxisArrays"
        }, 
        {
            "location": "/man/combining/#combing-multiple-timeaxisarrays", 
            "text": "TimeAxisArray  combination methods are identical to those in  AxisArray , but are documented here for convenience.", 
            "title": "Combing multiple TimeAxisArrays"
        }, 
        {
            "location": "/man/combining/#combining-on-existing-axes", 
            "text": "Multiple  TimeAxisArray s can be joined together along an existing axis with  merge  - this can be thought of as an axis-aware form of concatenation:  a = TimeAxisArray(ones(5), 7:11)\nb = TimeAxisArray(zeros(5), 1:5)\nmerge(a,b)  merge  works along any number of axes. If an axis coordinate appears more than once in the  TimeAxisArray s to be merged, the value in the last provided input is kept.  a = TimeAxisArray(ones(5,2), 1:5, [:A, :B])\nb = TimeAxisArray(zeros(5,2), 3:7, [:B, :C])\nmerge(a,b)  As shown above, in some cases new array elements that were not defined in any of the inputs to the merge will be created. By default these values are zero, but they can be set to any arbitrary value with the  fillvalue  keyword:  merge(a,b, fillvalue=NaN)", 
            "title": "Combining on existing axes"
        }, 
        {
            "location": "/man/combining/#combining-into-a-new-axis", 
            "text": "TimeAxisArrays  can also be combined so as to preserve elements at repeated axis coordinates by combining the inputs along a newly created axis with the  join  method:  join(a,b)  The name and values of the new axis can be specified using the  newaxis  keyword, and  fillvalue  can be provided as with  merge :  join(a,b, newaxis=Axis{:Order}([:First, :Second]), fillvalue=NaN)  Inner, left, right, and outer join methods are supported, with outer used by default:  join(a, b, method=:outer) # same as join(a,b)\njoin(a, b, method=:left)\njoin(a, b, method=:right)\njoin(a, b, method=:inner)", 
            "title": "Combining into a new axis"
        }, 
        {
            "location": "/man/downsampling/", 
            "text": "Splitting, collapsing, and downsampling on timestamps\n\n\n\n\nSplitting\n\n\nsplit\n partitions a \nTimeAxisArray\n into subgroups of array elements according to sequential timestamps that return the same value for some function. For example, to split apart a \nTimeAxisArray\n into multiple parts corresponding to different weeks:\n\n\nusing TimeAxisArrays\n\na = TimeAxisArray(randn(10), Date(2000,1,1):Date(2000,1,14))\nsplit(a, Dates.week)\n\n\n\n\n\n\nCollapsing\n\n\ncollapse\n reduces a \nTimeAxisArray\n to a single timestamp and corresponding values in each higher dimension. For example, to take the first timestamp of the input and the first value timewise in each other axis:\n\n\nb = TimeAxisArray(randn(5,3), Date(2000,1,1):Date(2000,1,:5), [:A, :B, :C])\ncollapse(a, first)\n\n\n\n\nThe value reduction function can optionally be specified separately from the timestamp reducer:\n\n\ncollapse(b, first, sum)\n\n\n\n\n\n\nDownsampling\n\n\ndownsample\n combines \nsplit\n and \ncollapse\n to group clusters of values in time, and then reduce the clusters to single values. For example, to downsample observations to a weekly average labelled by the first day of the week:\n\n\ndownsample(a, Dates.week, first, mean)", 
            "title": "Splitting, collapsing, and downsampling on timestamps"
        }, 
        {
            "location": "/man/downsampling/#splitting-collapsing-and-downsampling-on-timestamps", 
            "text": "", 
            "title": "Splitting, collapsing, and downsampling on timestamps"
        }, 
        {
            "location": "/man/downsampling/#splitting", 
            "text": "split  partitions a  TimeAxisArray  into subgroups of array elements according to sequential timestamps that return the same value for some function. For example, to split apart a  TimeAxisArray  into multiple parts corresponding to different weeks:  using TimeAxisArrays\n\na = TimeAxisArray(randn(10), Date(2000,1,1):Date(2000,1,14))\nsplit(a, Dates.week)", 
            "title": "Splitting"
        }, 
        {
            "location": "/man/downsampling/#collapsing", 
            "text": "collapse  reduces a  TimeAxisArray  to a single timestamp and corresponding values in each higher dimension. For example, to take the first timestamp of the input and the first value timewise in each other axis:  b = TimeAxisArray(randn(5,3), Date(2000,1,1):Date(2000,1,:5), [:A, :B, :C])\ncollapse(a, first)  The value reduction function can optionally be specified separately from the timestamp reducer:  collapse(b, first, sum)", 
            "title": "Collapsing"
        }, 
        {
            "location": "/man/downsampling/#downsampling", 
            "text": "downsample  combines  split  and  collapse  to group clusters of values in time, and then reduce the clusters to single values. For example, to downsample observations to a weekly average labelled by the first day of the week:  downsample(a, Dates.week, first, mean)", 
            "title": "Downsampling"
        }, 
        {
            "location": "/man/other/", 
            "text": "Other time series utilities\n\n\n\n\nRolling reductions\n\n\nmoving\n applies a reduction function to a moving window of values and assigns the output value to the final timestamp in the window. For example, to take a 10-element moving average:\n\n\nusing TimeAxisArrays\n\na = TimeAxisArray(cumsum(ones(15)), Date(2000,1,1):Date(2000,1,15))\nmoving(a, mean, 10)\n\n\n\n\n\n\nLead and lag\n\n\nlead\n and \nlag\n shift all values forwards or backwards one timestamp:\n\n\nlead(a)\n\n\n\n\n\n\nAbsolute and percent differencing\n\n\ndiff\n subtracts the value at each timestamp from the value preceding it. By default differencing is only applied once, but optional higher order differencing is possible as well:\n\n\ndiff(a) # Difference of values\ndiff(a,2) # Difference of difference of values\n\n\n\n\npercentchange\n performs a similar function, returning the percent difference between values at each timestamp and those immediately preceding them:\n\n\npercentchange(a)\n\n\n\n\nSetting the \nlogdiff\n keyword to true provides the percent change as the difference of logged values:\n\n\npercentchange(a, logdiff=true)", 
            "title": "Other time series tools"
        }, 
        {
            "location": "/man/other/#other-time-series-utilities", 
            "text": "", 
            "title": "Other time series utilities"
        }, 
        {
            "location": "/man/other/#rolling-reductions", 
            "text": "moving  applies a reduction function to a moving window of values and assigns the output value to the final timestamp in the window. For example, to take a 10-element moving average:  using TimeAxisArrays\n\na = TimeAxisArray(cumsum(ones(15)), Date(2000,1,1):Date(2000,1,15))\nmoving(a, mean, 10)", 
            "title": "Rolling reductions"
        }, 
        {
            "location": "/man/other/#lead-and-lag", 
            "text": "lead  and  lag  shift all values forwards or backwards one timestamp:  lead(a)", 
            "title": "Lead and lag"
        }, 
        {
            "location": "/man/other/#absolute-and-percent-differencing", 
            "text": "diff  subtracts the value at each timestamp from the value preceding it. By default differencing is only applied once, but optional higher order differencing is possible as well:  diff(a) # Difference of values\ndiff(a,2) # Difference of difference of values  percentchange  performs a similar function, returning the percent difference between values at each timestamp and those immediately preceding them:  percentchange(a)  Setting the  logdiff  keyword to true provides the percent change as the difference of logged values:  percentchange(a, logdiff=true)", 
            "title": "Absolute and percent differencing"
        }, 
        {
            "location": "/man/file-io/", 
            "text": "File IO\n\n\n\n\nReading from disk\n\n\n\n\nWriting to disk", 
            "title": "File IO"
        }, 
        {
            "location": "/man/file-io/#file-io", 
            "text": "", 
            "title": "File IO"
        }, 
        {
            "location": "/man/file-io/#reading-from-disk", 
            "text": "", 
            "title": "Reading from disk"
        }, 
        {
            "location": "/man/file-io/#writing-to-disk", 
            "text": "", 
            "title": "Writing to disk"
        }, 
        {
            "location": "/lib/", 
            "text": "#\n\n\nTimeAxisArrays.collapse\n \n \nFunction\n.\n\n\ncollapse(A::TimeAxisArray, tsreducer::Function, reducer::Function=tsreducer)\n\n\n\n\nCollapses the timestamps of \nA\n to a single observation in the time dimension using \ntsreducer\n. Data is collapsed in the time dimension using \nreducer\n, which defaults to \ntsreducer\n.\n\n\n#\n\n\nTimeAxisArrays.downsample\n \n \nFunction\n.\n\n\ndownsample(A::TimeAxisArray, splitter::Function, tsreducer::Function, reducer::Function=tsreducer)\n\n\n\n\nCombines \nsplit\n, \ncollapse\n, and \nvcat\n to partition \nA\n according to sequential values in the mapping of \nsplitter\n over the timestamps of \nA\n, then collapses each of the split TimeAxisArrays according to \ntsreducer\n (for timestamps) and \nreducer\n (for data), before recombining the collapsed values.\n\n\n#\n\n\nTimeAxisArrays.dropif\n \n \nMethod\n.\n\n\ndropif(selector::Function, predicate::Function, A::TimeAxisArray)\n\n\n\n\nDrops observations at timestamps where \nselector\n (e.g. \nany\n, \nall\n) data values statisfy \npredicate\n.\n\n\n#\n\n\nTimeAxisArrays.dropnan\n \n \nFunction\n.\n\n\ndropnan(selector::Function, A::TimeAxisArray)\n\n\n\n\nDrops observations at timestamps where \nselector\n (e.g. \nany\n, \nall\n) data values are NaN. Equivalent to \ndropif(selector, isnan, A)\n\n\n#\n\n\nTimeAxisArrays.lag\n \n \nFunction\n.\n\n\nlag(A::TimeAxisArray, k::Int=1)\n\n\n\n\nShifts all observations in \nA\n later in time by \nk\n timestamps.\n\n\n#\n\n\nTimeAxisArrays.lead\n \n \nFunction\n.\n\n\nlead(A::TimeAxisArray, k::Int=1)\n\n\n\n\nShifts all observations in \nA\n earlier in time by \nk\n timestamps.\n\n\n#\n\n\nTimeAxisArrays.moving\n \n \nMethod\n.\n\n\nmoving(A::TimeAxisArray, reducer::Function, n::Int)\n\n\n\n\nApplies a time-wise reduction specified by \nreducer\n to a moving window of \nn\n observations, storing the result at the last timestamp in the window.\n\n\n#\n\n\nTimeAxisArrays.percentchange\n \n \nMethod\n.\n\n\npercentchange(A::TimeAxisArray; logdiff::Bool=false)\n\n\n\n\nComputes the percent change between observations in time in \nA\n. If \nlogdiff\n is true, returns the difference of log-transformed values.\n\n\n#\n\n\nBase.LinAlg.diff\n \n \nFunction\n.\n\n\ndiff(A::TimeAxisArray, k::Int=1)\n\n\n\n\nPerform \nk\nth order differencing across time observations in \nA\n.\n\n\n#\n\n\nBase.split\n \n \nMethod\n.\n\n\nsplit(A::TimeAxisArray, f::Function)\n\n\n\n\nReturns an array containing sequential fragments of \nA\n, split according to clusters of values in the mapping of \nf\n over the timestamps of \nA\n. \nsplit(f, A)\n is also defined so as to support do-notation.", 
            "title": "Function Reference"
        }
    ]
}